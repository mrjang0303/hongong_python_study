# 문제: 프로그래머스 lv.1 '최대공약수와 최소공배수'
# 설명: 두 개의 자연수 n과 m을 입력받아, 최대공약수(GCD)와 최소공배수(LCM)를
#       이 순서대로 배열에 담아 반환해야 한다.
# 링크: https://school.programmers.co.kr/learn/courses/30/lessons/12940

# 풀이:
# 1. 원본 값 저장: 최소공배수(LCM) 계산을 위해 입력된 n, m의 원본 값을 저장한다.
# 2. 유클리드 호제법 적용: 두 수 중 큰 수를 작은 수로 나누는 과정을 반복하여 최대공약수(GCD)를 구한다.
#    - a = 큰 수 (나눠지는 수), b = 작은 수 (나누는 수)
#    - 'b > 0'일 때까지 반복하며, (새로운 a) = (이전 b), (새로운 b) = (이전 나머지)로 치환한다.
#    - 반복이 끝났을 때, a에 저장된 값이 최대공약수(GCD)이다.
# 3. 최소공배수(LCM) 계산: LCM = (원본 n * 원본 m) / GCD 공식을 사용하여 계산한다.
# 4. 반환: 최종적으로 [GCD, LCM] 순서로 리스트를 반환한다.

def solution(n, m):
    # 최소공배수 계산을 위해 원본 저장
    origin_n, origin_m = n, m
    
    # a는 큰 수(나눠지는 수), b는 작은 수(나누는 수)로 초기 설정
    a, b = max(n, m), min(n, m)
    
    # '나머지가 있다(b > 0)'면 계속 반복 (유클리드 호제법)
    while b > 0:
        a, b = b, a % b 
        # 설명: 
        # a 자리에는 이전의 b(작은 수)가 들어가고
        # b 자리에는 나머지(a % b)가 들어갑니다.
        # b가 0이 되면 반복문이 끝나고, a가 최대공약수가 된다.

    # [Point 3] 바로 리스트로 반환: [GCD, LCM]
    # 이 때, 여기서 a는 최대공약수(GCD)이다.
    return [a, (origin_n * origin_m) // a]